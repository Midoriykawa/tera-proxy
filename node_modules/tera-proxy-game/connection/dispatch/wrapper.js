/*	@@Mod API
	This API is exposed to mods as the first argument passed to their constructor. An example mod is as follows:
	```js
	module.exports = function HelloWorld(mod) {
	/	mod.log.info('Hello, world!')
	}
	```
*/

const logger = require('log'),
	path = require('path'),
	Settings = require('./settings'),
	Hotswap = require('./hotswap')

const kTimers = Symbol(),
	kSettings = Symbol()

const UNLOADED_PROTO = (() => {
	const error = (obj, key) => { throw Error(`Attempting to access property "${key}" after being unloaded`) }
	return new Proxy(Object.create(null), { get: error, set: error })
})()

class ModWrapper {
	constructor(modConstructor, info, dispatch, hotswapProxy) {
		const log = logger(info.name)

		Object.assign(this, {
			/*	#info
				`<Object>` A parsed version of this mod's `mod.json`.
			*/
			info,
			dispatch,
			name: info.name,
			/*	#log
				`<Object>` This mod's logger.
			*/
			log
		})

		this[kTimers] = new Set()
		this[kSettings] = new Settings(path.join(dispatch.modManager.settingsDir, this.name + '.json'), this.name)

		// Toolbox compatibility
		if(info._compat === 2) {
			Object.defineProperties(this, {
				activeTimeouts: {configurable: true, get() { return new Set([...this[kTimers]].filter(t => !t._repeat)) }},
				activeIntervals: {configurable: true, get() { return new Set([...this[kTimers]].filter(t => t._repeat)) }},
				command: {configurable: true, get() { return dispatch.require.command }},
				game: {configurable: true, get() {
					try {
						return dispatch.require['tera-game-state']
					}
					catch(e) {
						log.error('Please install tera-game-state:\n    https://github.com/tera-mods-forks/tera-game-state')
						throw e
					}
				}},
			})

			const dispatchOverride = {
				//protocol: require('tera-data-parser').protocol,
				moduleManager: {
					get: name => dispatch.loadedMods.get(name),
					isLoaded: name => this.isLoaded(name),
					isInstalled: name => this.isLoaded(name)
				},
				fromRaw: this.parse.bind(this),
				toRaw: this.serialize.bind(this)
			}

			let logAbuse = false
			function checkLogAbuse(msg) {
				if(logAbuse) return true
				if(msg.includes('trying to use this module on an unsupported')) {
					log.warn('This mod contains anti-features aimed at degrading user experience for tera-proxy users'
						+ '\nPlease contact [ Pinkie Pie#7969 ] on Discord to report this issue')
					return logAbuse = true
				}
			}

			Object.assign(this, {
				dispatch: new Proxy(dispatch, { get: (obj, key) => dispatchOverride[key] || obj[key] }),

				info: info._compatInfo,
				options: info._compatInfo.options,
				niceName: info._compatInfo.options.niceName,
				rootFolder: info._path,
				isClassic: this.patchVersion < 28,
				platform: this.patchVersion < 28 ? 'classic' : 'pc',
				manager: dispatchOverride.moduleManager,

				// Timers
				clearAllTimeouts() { for(let t of this[kTimers]) if(!t._repeat) this.clearTimeout(t) },
				clearAllIntervals() { for(let t of this[kTimers]) if(t._repeat) this.clearTimeout(t) },

				// Old functions
				tryHook(...args) { try { return this.hook(...args) } catch(e) { return null } },
				tryHookOnce(...args) { try { return this.hookOnce(...args) } catch(e) { return null } },
				trySend(...args) { try { return this.send(...args) } catch(e) { return false } },

				// Logging
				log(...msg) { msg = msg.join(' '); if(!checkLogAbuse(msg)) log.info(msg) },
				warn(...msg) { msg = msg.join(' '); if(!checkLogAbuse(msg)) log.warn(msg) },
				error(...msg) { msg = msg.join(' '); if(!checkLogAbuse(msg)) log.error(msg) },

				// Settings
				saveSettings() {}
			})

			// Settings migration
			const settingsVersion = this.options.settingsVersion
			if(settingsVersion)
				try {
					if(this.settings._version !== settingsVersion) {
						this.settings = require(
							path.join(this.rootFolder, this.options.settingsMigrator || 'module_settings_migrator.js')
						)(this.settings._version || null, settingsVersion, this.settings)
						this.settings._version = settingsVersion
					}
				}
				catch(e) {
					console.log(`[compat] Error migrating settings for "${this.name}"`)
					console.log(e)
				}

 			if(this.name !== 'tera-game-state')
				this.hook('S_RETURN_TO_LOBBY', 'raw', () => {
					for(let t of this[kTimers]) this.clearTimeout(t)
				})

			// Workaround improper usage
			if(this.info.servers && this.info.servers.some(s =>
				/^https:\/\/raw\.githubusercontent\.com\/(caali-hackerman|tera-toolbox(-mods)?|tera-shiraneko)\//i.test(s.toLowerCase())
			))
				dispatchOverride.proxyAuthor = this.proxyAuthor = 'caali'
		}

		if(info.reloadable) {
			if(hotswapProxy) {
				const instance = new modConstructor(this)

				if(typeof instance !== typeof hotswapProxy)
					throw TypeError(`Cannot hotswap to different type: ${typeof instance} (expected ${typeof hotswapProxy})`)

				this.instance = hotswapProxy
				this.instance.__target__ = instance
			}
			else this.instance = Hotswap(new modConstructor(this))
		}
		else this.instance = new modConstructor(this)
	}

	destroy(multiPass) {
		try {
			if(multiPass !== 2) {
				// Flush any changed settings to disk
				this[kSettings].flush()

				// Clear all timers
				for(let t of this[kTimers]) this.clearTimeout(t)

				// Call mod-defined destructor
				if(this.instance.destructor) {
					this.instance.destructor()
					return true
				}
			}
		}
		finally {
			// Attempt to dereference as much as possible, hopefully crashing any memory leaked functions
			if(multiPass !== 1) {
				const instanceUnloadedProto = (() => {
					const modName = this.name,
						error = (obj, key) => { throw Error(`Attempting to access property "${key}" of unloaded mod "${modName}"`) }
					return new Proxy(Object.create(null), { get: error, set: error })
				})()

				Object.setPrototypeOf(this.instance, instanceUnloadedProto)
				Object.setPrototypeOf(this, UNLOADED_PROTO)

				for(let obj of [this.instance, this]) {
					if(typeof obj === 'function') obj.prototype = undefined
					for(let key of Object.getOwnPropertyNames(obj)) try { delete obj[key] } catch(e) {}
					for(let key of Object.getOwnPropertySymbols(obj)) try { delete obj[key] } catch(e) {}
				}

				Object.freeze(this)
			}
		}
		return false
	}

	/*	#require
		`<Object>` A Proxy object which returns the specified mod's current instance. Throws an error if the required mod is not installed.
	*/
	get require() { return this.dispatch.require }

	/*	@isLoaded: name
		Returns #true if the specified mod is installed, #false otherwise.
	*/
	// Note: Calls require to prevent race condition
	isLoaded(name) {
		try {
			this.dispatch.require[name]
			return true
		}
		catch(e) { return false }
	}

	reload(name) { return this.dispatch.reload(name) }

	/*	#settings
		`<Object>` A persistent storage object backed by JSON. Each mod has their own #settings.
	*/
	get settings() { return this[kSettings].root }
	set settings(obj) {
		this[kSettings].loadRoot(obj)
		this[kSettings].changed()
	}

	/*	@setTimeout: callback, milliseconds[, ...args]
		Equivalent to `globalThis.setTimeout`, but is canceled when the mod is unloaded.
	*/
	setTimeout(cb, ms, ...args) {
		const timers = this[kTimers],
			t = setTimeout(function () {
				timers.delete(t)
				cb(...args)
			}, Math.floor(ms))

		timers.add(t)
		return t
	}

	/*	@setInterval: callback, milliseconds[, ...args]
		Equivalent to `globalThis.setInterval`, but is canceled when the mod is unloaded.
	*/
	setInterval(cb, ms, ...args) {
		const t = setInterval(cb, Math.floor(ms), ...args)
		this[kTimers].add(t)
		return t
	}

	/*	@clearTimeout: timeout
		Clears timers set by @setTimeout or @setInterval.
	*/
	clearTimeout(t) {
		clearTimeout(t)
		this[kTimers].delete(t)
	}

	/*	@clearInterval: timeout
		Clears timers set by @setTimeout or @setInterval.
	*/

	/*	@hook: id, def[, options], callback
		* #id `<String>` Packet name | `<Number>` Packet code | `'*'` All packets
		* #def `<Number>` Version number | `<Object>` Compiled protocol definition | `'raw'` Raw data
		* #options `<Object>`
		* * #order `<Number>` Hook priority. Lower numbers receive callbacks first, while higher numbers receive them later.
		* * #filter `<Object>`
		* * * #$fake `<Boolean>` | #null (default: #false)
		* * * #$incoming `<Boolean>` | #null (default: #null)
		* * * #$modified `<Boolean>` | #null (default: #null)
		* * * #$silenced `<Boolean>` | #null (default: #false)
		* * #timeout `<Number>` Milliseconds to wait before unhooking. When timeout occurs, #callback is fired with a single #null argument.
		* #callback `<Function>` in normal mode:
		* * #event `<Object>` The parsed data object
		* * * #$fake `<Boolean>`
		* * * #$incoming `<Boolean>`
		* * * #$modified `<Boolean>`
		* * * #$silenced `<Boolean>`
		* * #fake `<Boolean>` **`Deprecated`**
		* #callback `<Function>` in raw mode:
		* * #code `<Number>`
		* * #data `<Buffer>`
		* * * #$fake `<Boolean>`
		* * * #$incoming `<Boolean>`
		* * * #$modified `<Boolean>`
		* * * #$silenced `<Boolean>`
		* * #incoming `<Boolean>` **`Deprecated`**
		* * #fake `<Boolean>` **`Deprecated`**
		* Returns: `<Object>` The hook reference. See @unhook.
		Hooks a packet.
	*/
	hook(...args) { return this.dispatch.hook(this.name, ...args) }

	/*	@hookOnce: name, version[, options], callback
		Hooks a single packet, unhooking on callback. See @hook for options.
	*/
	hookOnce(...args) {
		const cb = args.pop()
		if(typeof cb !== 'function') throw Error('last argument not a function')

		const dispatch = this.dispatch
		return this.hook(...args, function(...hookArgs) {
			dispatch.unhook(this)
			return cb.call(this, ...hookArgs)
		})
	}

	/*	@hookAsync: name, version[, options], callback
		Returns a Promise that resolves with #event or rejects if timed out. See @hook for options.
	*/
	hookAsync(...args) {
		return new Promise((resolve, reject) => {
			this.hookOnce(...args, event => {
				if(event) resolve(event)
				else reject(Error('Hook timed out'))
			})
		})
	}

	/*	@unhook: hook
		Unhooks a previously hooked packet. If #hook is invalid, then this method silently fails.
	*/
	unhook(...args) { return this.dispatch.unhook(...args) }


	/*	@send: id, def[, object]
		* Returns: `<Boolean>` Success
		Sends a packet, inferring direction from the packet's name. Fields not specified are set to default values.
	*/
	send(name, version, data) {
		if(typeof name !== 'string') throw TypeError('Raw send() is not supported')

		switch(name[0]) {
			case 'C':
				return this.dispatch.write(true, name, version, data)
			case 'I':
			case 'S':
				return this.dispatch.write(false, name, version, data)
			default:
				throw Error(`Unknown packet direction: ${name}`)
		}
	}

	/*	@toClient: id, def[, object] | data
		* Returns: `<Boolean>` Success
		Sends a packet to the client. Fields not specified are set to default values.
	*/
	toClient(...args) { return this.dispatch.write(false, ...args) }

	/*	@toServer: id, def[, object] | data
		* Returns: `<Boolean>` Success
		Sends a packet to the server. Fields not specified are set to default values.
	*/
	toServer(...args) { return this.dispatch.write(true, ...args) }

	compileProto(...args) { return this.dispatch.protocol.compileProto(...args) }
	getProto(...args) { return this.dispatch.protocol.getProto(...args) }
	parse(...args) { return this.dispatch.protocol.read(...args) }
	serialize(...args) { return this.dispatch.protocol.write(...args) }
	packetLength(...args) { return this.dispatch.protocol.length(...args) }

	parseSystemMessage(...args) { return this.dispatch.parseSystemMessage(...args) }
	buildSystemMessage(...args) { return this.dispatch.buildSystemMessage(...args) }

	get protocolVersion() { return this.dispatch.protocolVersion }
	get region() { return this.dispatch.region }

	/*	#patchVersion
		`<Number>` A getter which returns the game's version number (ie. 93.04).
	*/
	get patchVersion() { return this.dispatch.getPatchVersion() }
	get majorPatchVersion() { return this.dispatch.majorPatchVersion }
	get minorPatchVersion() { return this.dispatch.minorPatchVersion }
}

// Assign aliases
(function() {
	Object.assign(this, {
		clearInterval: this.clearTimeout
	})
}).call(ModWrapper.prototype)

module.exports = ModWrapper